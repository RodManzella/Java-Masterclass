The switch statement

Switch(value){
    case x:
        //code for value x
        break,

    case y:
        // code for value y
        break;
    default:
        // code for value not equal to x or y
}

Another important thing to know, is that the switch statement can only be used with a limited type of variable data types.


Valid Switch Value types:

----------------------------
byte, short, int, char

Byte, Short, Integer, Character

String

enum
-------------------------------

important: Cannot use long, float, double or boolean or their wrappers.


Fall through in switch statement

Once a switch case label matches the switch variable, no more cases are checked.

Any code after the case label where there was a match found, will be executed, until a break statement, or the end
of the switch statement occurs.

Without a break statement, execution will continue to fall through any case labels declared below the matching one, and
execute each case´s code.

=======================================================================================================================================

More switch statement

since JDK 9, the switch has been undergoing enhancements, but to keep it backwars compatible, Java has introduced a new syntax
for the switch as shown below:

Traditional Swicth statement:

switch(switchValue){  //check the variable switchValue
    case 1:                                              
        System.out.println("Value was 1");
        break;  
    case 2:
        System.out.println("Values was 2");
        break;
    case 3: case 4: case 5:                           
        System.out.println("Was a 3, a 4 or a 5");
        System.out.println("Actually, it was a "+switchValue);
    default:
        System.out.println("Was not 1, 2, 3, 4, or 5");  
        }


Enhanced switch statement:

switch(switchValue){
    case 1 -> System.out.println("Value was 1");
    case 2 -> System.out.println("Value was 2");
    case 3, 4, 5 ->{
        System.out.println("Was a 3, a 4 or a 5");
        System.out.println("Actually, it was a "+switchValue);
    }
    default -> System.out.println("Was not 1, 2, 3, 4, or 5");  
}


-----------------------------------------------------------------------------------------------------------

Traditional switch statement  vs   Enhanced Switch Expression


 switch(month){
    case "JANUARY":
    case "FEBRUARY":
    case "MARCH":
        return "1st";
    case "APRIL":
    case "MAY":
    case "JUNE":
        return "2nd";
    case "JULY":
    case "AUGUST":
    case "SEPTEMBER":
        return "3rd";
    case "OCTOBER":
    case "NOVEMBER":
    case "DECEMBER":
        return "4th";
}
 return "bad";





    return switch (month){
            case "JANUARY", "FEBRUARY", "MARCH" -> "1st";
            case "APRIL", "MAY", "JUNE" -> "2nd";
            case "JULY", "AUGUST", "SEPTEMBER" -> "3rd";
            case "OCTOBER", "NOVEMBER", "DECEMBER" -> "4th";
            default -> "bad";
        };


We can see that the multiple case keyword have been removed, for a comma delimited list, and the colon is replaced with an arrow token,
so this looks a lot like the enhanced switch statement. But look at the right side of the arrow token, it´s just a String literal. This
isn´t a statement at all. This  code only compiles because we´re using it as an expression, meaning we´re using the result. In this case,
we´re simply returning the result from the method, but we just as easily have assigned it to a local variable. The other important difference
is this default label. When the enhanced switch is an expression, meaning it returns a value, then a default label is required under most 
conditions. We´ll be talking about the exception to this rule later, when we use the switch with the last special type it supports, the enum.
But in all other cases, default is required when the statement is used as an expression. So let´s test these statements in our code.

--------------------------------------------------------------------------------------------------------------------------------------

When to use yield in a switch:

Your switch statement is being used as a switch expression returning a value

    This code                is implicitly translated to 

    -> "1st";                 {yield "1st";}     // yield statement has to be in a code block {}


Generally, if all you´re doing is returning the value from one of your cases, you´ll just put the value that is returned.
But if you´re making calculations, or doing some other work, you can use a code block, but you´re then required to use yield
before you return the value back.

===========================================================================================================================================

Looping

Looping lets us execute the code a multiple number of times.

There are several looping statements in Java. These statements will continue to execute a code of block repetively,until a condition, or
some set of conditions is met.



Java supports three statements for looping:

    for: The for loop is more complex to set up, but is commonly used when you are iterating over a set of values.

    while: The while loop executes until a specified condition becomes false.

    do while: The do while loop always executes at least one and continues until a specified condition becomes false.


-----------------------------------------------------------------------------------------------------------------------
The for statement

The for statement is often referred as the foor loop.

It repeatedly loops something until a condition is satisfied.


    for(init; expression; increment){
        // block of statements
    }

There are three parts of the basic statement´s declaration.

    These are declared in parentheses, after the for keyword, and are separated by semi-colons.

    These parts are all optional and consist of the following:

        The initialization section declares or sets state, usually declaring and initializing a loop variable, before the loop 
        begins processing.

        The expression section, once it becomes false, will end the loop processing.

        The increment section is executed after the expression is tested, and is generally the place where the loop variable is incremented.


-----------------------------------------------------------------------------------------------------------------------------------------------
Other ways to loop

What if you want to loop until some condition is met, that´s not associated with a known range of values?


Java has two types of while loops:

    while: Continue executing code block until the loop expression becomes false.

    do while: Execute the code block once, then continue executing until the loop condition becomes false.


continue

    The continue statement, in it´s simplest form, will stop executing the current iteration of a block code in a loop, and start a new iteration.

----------------------------------------------------------------------------------------------------------------------------------------------------------
Local variables and scope:

    In the past couple of videos, we´ve looked at many of Java´s flow statements, the switch statement, the for statement, the while
    statement, as well as the do while statement.

    In previous videos, we covered the if then else statement.

    All of these statements may, and probably will have their own code blocks.

    We´ve talked about code blocks quite a bit, but we haven´t really talked about variables declared locally to many of these blocks.


Local variable

    A local variable is called local, because it is available for use by the code block in which was declared.

    It is also available to code blocks that are contained by a declaring block.


    {
        int firstVariable = 5;
        int secondVariable = 10;

        if(firstVariable > 0){ // flow statement block starts inner block
            
            // Inner block code has acess to outer block´s variables
            System.out.println(secondVariable);
        }
    }


Scope

    Scope describes the acessibility of a variable.

    'In scope' means the variable can be used by an executing block or any nested any nested blocks.

    'Out of scope' means the variable is no longer available.



When are Local Variables in Scope?

    Local variablea are always in scope, in the block they are declared.

    They are also in scope for any nested blocks, or blocks contained within the outer block.

    For example, a method block can declare local variables, and any flow statements contained in the method block will have
    acess to the method´s local variables. This is also true for the method parameters. Any code in the method, and any nested
    blocks have acess to the parameters. There is no limit to how deep you can nest code blocks, but generally, for readability
    and maintainability, consider  replacing deeply nested blocks with method calls.



When are Local Variables out of Scope?

    Local variables are always out of scope, for outer blocks, or the containing blocks they are declared in.



    public static void aMethod(boolean aBoolean){

        if(aBoolean){
            int myCounter = 10;    //myCounter is local to this if block
        }
        System.out.println(myCounter);   //myCounter is out of scope here
    }



Scope best practices

    It is considered best practice:

        To declare and initialize variables in the same place if possible.

        And to declare variables in the narrowest scope possible(If you´re variable is only used in a nested block, declare it there)

        Example: if you are using a variable only in a loop code block, like the iteration variable, and won´t be using it
        outside of the loop block, declare it in the loop code, or in the for loop initialization block.




Local variables and the For statement

    In this for statement, as part of the declaration, there is an initialization part, as we´ve described.

    In this case, we declared a variable i, that isn´t acessible outside of the loop.

    this is because any variables declared in the init section, are local to the loop, meaning they exist and are acessible
    in memory, only while the loop is executing, and only to the loop code block.


    {  //Starts outer code block - for example a method block

        for(int i = 1; i < 5; i++){   // i declared in for loop declaration
            System.out.println(i);
        }
        System.out.println(i);  //ERROR! this i is out of scope

    }




    let´s show for the if statement aswell:

    Local variables declared in an if statement block, are not acessible outside of that block.

    This also includes other parts of the if statement, like the else if block. or the else block.


    public static void aMethod(int counter){
        if(counter > 0){
            int i = 10;
        }
        else{
            System.out.println(i);    // ERROR: i is out of scope
        }

        System.out.println(i);   // ERROR: i is out of scope
    }















