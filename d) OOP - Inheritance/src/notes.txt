What is object oriented programming

    - Object oriented programming is a way to model real world objects, as software objects, which contain both data and code.

    - OOP is a common acronym for Object Oriented programming

Class-based programming

    - Class-based programming starts with classes, which become blueprints for objects.


State and Behaviour

    - Now, real world objects have two major coomponents: (state and behaviour)

    - State, in terms of a computer object, might be: The amout of RAM it has, the operating system it´s running, the hard drive size.

    - These are characteristics about the item, that can describe it.

    - Behaviour(computer): In addition to state, objects may also have a behaviour, or actions that can be performed by the object or upon the
      object. Behaviour, for a computer, might be things like: booting up, shuting down, outputing some form of sound, drawing something on the
      screen and so son.

    - So modelling real world objects as software objects, is a fundamental part of Object Oriented Programming.

    - Now, a software object stores its state in fields, which can also be called variables, or attributes.

    - And objects expose their behaviour with methods, which we-ve talked about before.

    - So, where does a class fit in?

    - Well, think of a class as a template, or blueprint for creating objects.

The class as the blueprint

    - The class describes the data(fields), and the behaviour (methods), that are relevant to the real world object we want to describe.

    - These are called class members.

    - A class member can be a field, or a method, or some other type of dependant element.

    - If a field is static, there is only one copy in memory, and this value is associated with the class, or template itself.

    - If a field is not static, it´s called an instance field, and each object may have a different value stored for this field.

    - A static method can´t be dependant on any one object´s state, so it can´t reference any instance members.

    - In other words, any method that operates on instance fields, needs to be non-static.
------------------------------------------------------------------------------------------------------------------------------------------------

Organizing classes

    -Classes can be organized into logical groupings, which are called packages.

    -You declare a package name in the class using a package statement.

    -If you don´t declare a package, the class implicitly belongs to the default package.

    - You do need to understand that classes are grouped into packages, to understand acess modifiers.


Acess modifiers for the class

    - A class is said to be a top-level class, if it is defined in the souce code file, and not enclosed in the code block of another class,
    type, or method.

    - A top level class has only two valid acess valid modifier options: public, or none.
        
        public: public means any other class in any package can acess this class.

        (empty): When the acess modifier is omitted, this class has special meaning, called package acess, meaning that the class is
                 acessible only to classes in the same package.


Acess modifiers for class members

    - An acess modifier at member level, allows granular control over class members.

    - The valid acess modifiers are shown in this table from the least restrictive, to the most restrictive

        public: public means any other class in any package can acess this class.

        protected: protected allows classes in the same package, and any subclasses in other packages, to have acess to the member

        (omitted): When the modifier is omitted(not specified), this class has special meaning, called package acess, meaning the member
                   is acessible only to classes in the same package.

        private: private means that no other class can acess this member

    - As a general rule, all your fields should be private, unlike the class, where we´ll usually use public. So why would we want to make
      all the fields on a class private? Doesn´t this mean that nobody can acess them? This practice has a name, encapsulation, and it´s A
      key fundamental rule of Object Oriented Programming.


Encapsulation


    - Encapsulation in Object Oriented Programming usually has two meanings.

    - One is the bundling(empacotamento) of behaviour and attributes on a single object.

    - The other is the practice of hiding fields, and some methods, from public acess.

    - In general, when we´re talking about encapsulation, we´re talking about information hiding, or hiding the internal workings of a 
      particular object. When we make our attributes private, we can then create methods to acess the data, with different degrees of
      acess allowed, as needed.

============================================================================================================================================
What is null?

    - null is a special keyword in Java, meaning the variable or attribute has a type, but no reference to an object.

    - This means that no instance, or object, is assigned to the variable or field.

    - field with primitive data types are never null.

    - So, why is the color, make, and model of the car null? Well, all of these fields were declared with the String data type, and we
      haven´t assigned values to them. We know from previous lectures that Strings are really objects, and not primitive data types,
      so Java assigned each a null reference.

    - the other thind i want you to notice about the output we got, was that doors was printed with the value 0(Car class) and that the world
      convertible wasn´t printed in the output. So, how is that possible? We didn´t set doors or convertible to any values in our class, but
      we didn´t get any erros when running this code. And now, we´re seeing another difference between local variables, and fields declared on
      a class.

    - And this is that a field with primitive data type, will get assigned a defaul value by Java.


Default values for fields on classes

    - Fields on clases are assigned default values, intrinsically by Java, if not assigned explicitly.

        boolean:                         defalt value assigned is false

        byte, short, int, long, char:    default value assigned is 0

        double, float:                   default value assigned is 0.0

        any other data type:             default value assigned is null
----------------------------------------------------------------------------------------------------------------------------------------------------

What are getters and setters? Why should we use them?

    - A getter is a method on a class, that retrives the value of a private field, and returns it.

    - A setter is a method on a class, that sets the value of a private field.

    - The purpose of these methods is to control, and protect acess to private fields.

    - Another important aspect, is that the getter and setter method signatures are part of car's public interface, but the attribute names
      and types aren´t. This means that we can chage things internally, like the name or type of an attribute, but as long as we use the
      same getter and setter method, these changes should  have no effect on code that uses our class. Our internal changes are hidden from
      our users.

    - A getter method usually just returns the value of a private attribute. It´s usual to name a getter method with the get prefix, followed
      by the field name, in lower camel case, but this is not required.

    - You could have getter methods for attributes that are not really declared on your class, but that are derived in some way.

    - A setter may simply just assign the argument passed to the attribute, but it often contains code to validate dara, check additional
      security requirements, ensure immutability of the field value, or any other code required to protect and validate an object´s state.

    - It´s usual to name a setter method with the set prefix, followed by the field name, in lower camel case, but again, this is matter of
      form. There may be cases where we won´t have any setter methods, for some of our private fields. Maybe this is data only needed within
      the class itself, and doesn´t need to be exposed to the outside world.

-----------------------------------------------------------------------------------------------------------------------------------------------
this keyword

     - this is a special keyword in Java.
     
     - What it really refers is to the instance that was cerated when the object was instantiated.

     - So "this" is a special reference name for the object or instance, which can be used to describe itself.

     - And we can use "this" to acess fields on the class.


Interesting details:

    Car car;
    car.setMake("Porsche");

    - We haven´t included the = new Car part. Already, IntelliJ is saying "Variable car may not have been initialized" where we are
      attempting to call the setter method, on the car variable. You can´t use an unitialized variable, which car is, because we haven´t
      assigned any object reference to it. But now, consider what happens, if we instead assign null to car
 
    Car car = null;
    car.setMake("Porsche");

    - So IntelliJ is not showing any erros when we do this, but let´s try running it.

        Exception in thread "main" java.lang.NullPointerExceptio: Cannot invoke "Car" at Main.main

    - We actually get an exception, NullPointerException, and the additional information that we can´t call a method, or invoke a method
      (instance method) on a null instance. And what that essentialy means, is we´ve defined a variable called car, but it doesn´t have a
      reference to a valid instance of a Car.
    
    - So we can´t run a method on a null, and we couldn´t set, or get attributes on a null.

    - So there´s a dinstinction here i want to point out, between an uninitialized variable, and a variable with a null reference.

    - An uninitialized variable, as we saw in the first instance, causes a compile time error. But a variable with a null reference can be
      be used in code, without compile errors, but will throw an expection at runtime.

    - So, in both of these scenarios, we haven´t created an object from the Car template, which of course is the class. So, that´s why you need
      to make sure that new is always executed. The bottom line i´m trying to say here is that, make sure when you´re creating objects, you always
      use the keyword new, and them include the name of the class, and then follow it with the parentheses.
=======================================================================================================================================================

Constructor

A constructor is used in the creation of an object, that´s an instance of a class.

It is a special type of code block that has a specific name and parameters, much like a method.

It has the same name as the class itself, and it doesn´t return any values.

You never include a return type from a constructor, not even void.

You can, and should, specify an appropriate access modifier, to control who should be able to create to create new instances of the class.



    public class Account{   //This is the class declaratiom

      public Account(){  // This is the constructor declaration
          // Constructor code is code to be executed as the object is created.
      }
    }
  

The default constructor

If a class contains no constructor declarations, then a default constructor is implictly declared.

This constructor has no parameters, and is often called the no-args (no arguments) constructor.

If a class contains any other constructor declarations, then a default constructor is NOT implicitly declared




The purpose of the constructor is, to essentially initialize the object that we´re creating, and do whatever else we need to happen,
while the object is being instantiated.



Constructor overloading is declaring multiple constructors, with different formal parameters.

The number of parameters can be different between constructors.

Or if the number of parameters is the same between two constructors, their types or order of types must differ.

================================================================================================================================================

Constructor chaining with this()

Constructor chaining is when one constructor explicitly calls another overloaded constructor.

You can call a constructor only from another constructor

You must use the special statement this() to execute another constructor, passing it arguments if required.

And this() must be the first executable statement, if it´s used from another constructor.

==============================================================================================================================================

Reference vs Object vs Instance vs Class



Let´s use the analogy building a house to understand classes.

A class is basically a blueprint for the house

Using the blueprint, we can build as many houses as we like, based on those plans.

Each house we build (in other words using the new operator) is an object.

This object can also be known as an instance, often we´ll say it´s an instance of the class. So we would have an instance of house
in this example.

Each house we build has an address(a physical location).

In other words, if we want to tell someone where we live, we give them our address (perhaps written on a piece of paper). This is known as
a reference.

We can copy that reference as many times as we like, but there is still just one house that we´re referring to.

In other words, we´re copying the paper that has the address on it, not the house itself.

We can pass references as parameters to constructors and methods.

================================================================================================================================================

Static vs Instance variables


Static variables

 - Declared by using the keyword static.

 - static variables are also known as static member variables.

 - Every instance of the class shares the same static variable.

 - So if changes are made to that variable, all other instances of that class will see the effect of that change.

 - It is considered best practice to use the Class name, and not a reference variable to acess a static variable.

    class Dog{
        
        static String genus = "Canis";

        void printData(){
          Dog d = new Dog();
          System.out.println(d.genus);     // Confusing!
          System.out.println(Dog.genus);   // Clearer!
        }
    }

    This makes it clearer that the variable is associated with the Class, and therefore shared and the value is not stored with the
    instance.

  - An instance insn´t required to exist, to acess the value of a static variable.

    class Dog{
      static String genus = "Canis";
    }

    class Main{
      public static void main(String [] args){
        System.out.println(Dog.genus);          //No instance of dog needs to exist in order to acess a static variable.
      }
    }

  - Static variables aren´t used very often, but can sometimes be very useful.

  - They can be used for:
    Storing counters.
    Generating unique ids.
    Storing a constant value that doesn´t change, like PI for example.
    Creating and controlling acess, to a shared resource.


    - example of code:

      class Dog{

        private static String name;

        public Dog(String name){
            Dog.name = name;
        }

        public void printName(){
            System.out.println("name = " + name);   // Using Dog.name would have made this code less confusing
        }
      }


      public class Main{

        public static void main(String [] args){

            Dog rex = new Dog("Rex");            // create instance (rex)
            Dog fluffy = new Dog ("Fluffy");     // create instance (fluffy)
            rex.printName();                     // prints Fluffy
            fluffy.printName();                  // prints Fluffy
        }
      }

      Both method calls print fluffy, why is that the case? Well, remember that static variables are shared between instances. So, in other
      words, once we change the static variable, all instances will see that change. So, when we called the cosntructor with the parameters
      fluffy, it modified the static variable name, because both instances are sharing that variable. So, you could say that all dogs have
      the same name, but that´s logically incorrect. So, hopefully, now you can see how static variables can be used inappropriately sometimes,
      as in this example.



      Instance variables

       - They don´t use the static keyword.

       - They´re also known as fields, or member variables.

       - Instance variables belong to a specific instance of a class.

       - Each instance has its own copy of an instance variable.

       - Every instance can have a different value.

       - Instance variables represent the state of a specific instance of a class.

       - Let´s see an example:
         
         
         class Dog{

            private String name;
            
            public Dog(String name){
               this.name = name;
            }

            public void printName(){
               System.out.println("name = " +name);
            }
         }

         public class Main{

            public static void main(String []args){

                Dog rex = new Dog("Rex");               // create instance (rex)
                Dog fluffluy = new Dog("Fluffy");       // create instance (fluffy)
                rex.printName();                        // prints Rex
                fluffly.printName();                    // prints Fluffy
            }
         }

================================================================================================================================================


Static vs Instance methods


Static Methods

  - Static methods are declared using a static modifier.

  - Static methods can´t acess instance methods and instance variables directly.

  - They´re used for operations that don´t require any data from an instance of the class (from 'this')

  - If you remember, the this keyword is the current instance of a class.

  - So, inside a static method, we can´t use the this keyword

  - Whenever you see a method that doesn´t use instance variables, that method should probably be declared as a static method.

  - For example, the main is a static method, and it´s called by the Java Virtual Machine when it starts the java application.

  - Static method example:


      class Calculator{
          
          public static void printSum(int a, int b){
              System.out.println("sum = "+ (a+ b));
          }
      }


      public class Main{
          
          public static void main(String [] args){
              Calculator.printSum(5, 10);
              printHello();                    // shorter form of Main.printHello();
          }

          public static void printHello(){
              System.out.println("Hello");
          }
      }

    - Static methods are called as ClassName.methodName(); or methodName(); only if in the same class


Instance methods

  - Instancce methods belong to an instance, of a class.

  - To use an instance method, we have to instantiate the class first, usually by using the new keyword.

  - Instance methods can acess instance variables directly.

  - Instance methods can also acess static methods and static variables directly.

  - What i mean by directly is that we don´t usually have to use the keyword this, with the dot notation to use them. And we don´t have
    to use the Class name with the dot notation to acess static variables, though that can help with clarity.

  - Instance Method example:

      class Dog{

          public void bark(){
              System.out.println("woof");
          }

          public class Main{

              Dog rex = new Dog();               // create instance
              rex.bark();                        // call instance method
          }
      }

    - So, the hard part here could be deciding when to create an instance, or when to create a static method. So, let´s see some basic rules
      that could help you decide.


          1) Shoud a method be static?

          2) Does it use any fields (instance variables) or instance methods?

          3) Yes: It should probably be an instance method.

          4) No: It should probably be an static method.

=================================================================================================================================================

The POJO

  - A plain old Java object (whose acronym is POJO) is a class that generally only has instance fields.

  - It´s used to house data, and pass data, between functional classes.]

  - It usually has few, if any methods other than getters and setters.

  - Many database frameworkds use POJO´s to read data from, or to write data to databases, files or streams.

  - You´ll remember, i´ve said several times that a class can be thought of as a super data type. A POJO is really just that. It let´s you
    extend and combine, your definition of data types.

   
    Examples of POJOS

      - A POJO also might be called a bean, or a JavaBean.

      - A JavaBean is just a POJO, with some extra rules to applied to it.

      - These rules are in place, so that Java frameworks have a standard way to manipulate, and manage these objects.

      - A POJO is sometimes called an entity, because it mirrors database entities.

      - Another acronym is DTO, for Data Transfer Object.

      - It´s a description of an object, that can be modeled as just data.

      

      Support for POJO creation

        - There are many tools, that will turn a data model into generated POJO´s or JavaBeans.

        - You´ve seen an example of similar code generation in IntelliJ, which allowed us to generate getters, setters, and constructors
          in a uniform way.

          - Let´s look at an example of a POJO in code(RecordProject folder). Let´s say we want to read data out of a database, that has a
            table of Student records.

          - The Entity - The Student table

                  Student

                  Id
                  Name
                  DateOfBirth
                  ClassList


Annotation (@)

  - Annotations are a type of metadata.

  - Metadata is a way of formally describing additional information about our code.

  - Annotations are more structured, and have more meaning than comments.

  - This is because they can be used by the compiler, or other types of pre-processing functions, to get information about the code.

  - Metadata doesn´t affect how your code runs, so this code will still run. with, or without the annotation.

  - Override is one of the most common annotations in Java that you´ll use.

  - It tells that compiler that this is a special type of method in Java, an overriden method.



Overriden Method

  - An overriden method is not the same as an overloaded method.

  - An overriden method is a special method in Java, that other classes can implement, if they use a specified method signature.

===============================================================================================================================================

The POJO vs The Record

  - In the last video, we talked about the Plain Old Java Object, and we showed you how it comes with a lot of what we call boilerplate code.

  - It´s code that´s repetitive, and follows certain rules.

  - In our case, we had a constructor with parameters for every field on our class, as well as getters and setters for each field. We also
    set up a toString method on this class, so we could print out all the fields on our class in a nicely formatted way.

  - This is code that´s repeated over and over, for every POJO, or for every JavaBean, if you are using JavaBeans to leverage Java frameworks
    that use them.

  - Once created, this code is rarely looked at, or modified.

  - In fact, there are tools that´ll just regenerate all of this code, if your underlying data, or domain model changes.

  - Even better though, Java introduced a new type, the record, which became part of the official language, in JFK 16.
  

The Record type

  - The record was introduced in JDK 14, and became officialy part of Java in JDK 16.

  - It´s purpose is to replace the boilerplate code of the POJO, but to be more restrictive.

  - Java calls them "plain data carriers".

  - The word carrier is an important term, because it means the record has more rules built-in then a POJO would.

  - The record is a special class that contains data, that´s not meant to be altered.

  - In other words, it seeks to achieve immutability, for the data in its members.

  - It contains only the most fundamental methods, such as constructors and accessors.

  - Best of all, you the developer, don´t have to write or generate any of this code.

  - Why is the record built to be immutable?

      The are more use cases for immutable data transfer objects, and keeping them well encapsulated.

      You want to protect the data from unintended mutations.


Pojo vs Record

  - If you want to modify data on your class, you won´t be using the record.

  - you can use the code generation options for the POJO, as we showed in the earlier video.

  - But if you´re reading a lot of records from a database or file source, and simply passing this data around, then the record is a big
    improvement.

We´ve only touched some of the features of the record to give you an introduction. When we do talk more about the final keyword, and
immutability of data, especially as it may be affected by concurrent threads, we´ll be revisiting this type. We´ll also be showing it to
you in action, when we get to the database and I/O sections of this course.

=================================================================================================================================================

Inheritance

  - What is inheritance, and why is it so powerful

  - We can look at Inheritance as a form of code re-use.

  - It´s a way to organize classes into a parent-child hierarchy, which lets the child inherit(re-use) fields and methods from its parent.



super()

 - super() is a lot like this().

 - It´s a way to call a constructor on the super class, directly from the sub class´s constructor.

 - Like this(), it has to be the first statement of the constructor.

 - Because of that rule, this() and super() can never be called from the same constructor.

 - If you don´t make a call to super(), then Java makes it for you, using super´s default constructor.

 - If your superclass doesn´t have a default constructor, than you must explicitly call super() in all of your constructors, passing the right
   arguments to that constructor.

===============================================================================================================================================
Code Re-use

  - All subclasses can execute methods, even though the code is declared on the parent class.

  - The code doesn´t have to be duplicated in each subclass.

  - We can use code from the parent

  - Or we can change that code for the subclass

-------------------------------------------------------------------------------------------------------------------------------------------

Overriding a method

  - Overriding a method is when you create a method on a subclass, which has the same signature as a method on a super class.

  - Remember that a method signature consists of the method name, and the number and types of parameters.

  - You override a parent class method, when you want the child class to show different behavior for that method.

  - The overriden method can do one of three things:

    It can implement completely different behavior, overriding the behavior of the parent.

    It can simply call the parent class´s method, which is somewhat redundant to do.

    Or the method can call the parent class´s method, and include other code to run, so it can extend the funcionality for the Dog, for that
    behavior.
-------------------------------------------------------------------------------------------------------------------------------------------

Polymorphism

  - Polymorphism simply means 'many forms'.
  
  - In this video, we showed that Animal can take multiple forms, the base classe Animal, or a dog, or a Fish. And as you´ve seen, some
    advantages of Polymorphism are: It makes code simpler. We can write code once, using the base class, or super class, as we did with our
    doAnimalStuff method. We wrote that code without ever having to know about subclasses types. We didn´t have to write code to check the types
    of object, and then decide what method to call, Java did that at runtime.

  - It encourages code extensibility. It´s very easy to subclass, and override or extend the method, that´ll be called as we demonstrated.

============================================================================================================================================== 


Inheritance looks kind of interesting, but when would we really use it?

Well, it turns iut, In Java, we´ve been using inheritance all along.


java.lang.Object

  - This is because every class you create in Java, intrinsically extends a special Java class.

  - This class is named Object, and it´s in the java.lang package.

  - Ok, that´s confusing, a class called Object?

  - Let´s see what Java has to say about this class.

  - We´ll use the link to Java´s application Programming Interface (API) for this class, which you can find in the resources section of
    this video.]

    

Class Object

  - Class Object is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the
    methods of this class.

    - Wheteher you knew it or not, your classes were extending this class, Object.

    - All of your classes have functionality built in that you can use or override, the minute you create them.

    - Let´s explore the methods on java.lang.Object

=================================================================================================================================================
this vs super

Let´s discuss the difference between this, and the super keywords.

We´ll also find out about the differences between the this(), and super(), method calls.


Let´s start with the super, and the this keywords first.

  - The keyword super is used to acess or call the parent class members(variables and methods)

  - The keyword this is used to call the current class members (variables and methods)

  - this is required when we have a parameter with the same name, as an intance variable, or field.

  - NOTE: We can use either of them anywhere in a class, except for static elements, like a static method. Any attempt to do so there, will
          lead to compile time errors.



  - The keyword this, is commonly used with constructors, setters and optionally used in getters.

  - In thhis example, we´re using the this keyword int the constructor and setter, since there´s a parameter with the same name, as the
    instance or field.

  - In the getter, we don´t have any parameters, so there´s no conflict, so therefore the this keyword is optional there.


      public class House{
          
          private String color;

          public House(String color){
              // this keyword is required, same parameter name as field.
              this.color = color;
          }

          public String getColor(){
              // this is optional
              return color;        // same as return this.color;
          }

          public void setColor(String color){
              // this keyword is required, same parameter name as field.
              this.color = color;
          }
      }

    

  - The keyword super, is commonly used with method overriding, when we call a emthod with the same name from the parent class.

  - In this example, we have a method called printMethod, that calls super.printMethod. In other words, it´s calling the method with the same
    name from the parent class.

   
        class Superclass{                     // parent class aka super class

            public void printMethod(){
                System.out.println("Printed in SuperClass.");
            }
        }

        class SubClass extends SuperClass{   // subclass aka child class

            // overrides methods from the parent class.
            @Overrride
            public void printMethod(){
                super.printMethod();                // calls the method in the SuperClass(parent)
                System.out.println("Printed in Subclass");
            }
        }

this() vs super() call

In Java we´ve got the this() and super() call. Notice the parentheses.

These are known as calls, since it looks like a regular method call, although we´re calling certain constructors.


  - Use this() to call a constructor, from another overloaded constructor in the same class.

  - The call to this() can only be used in a constructor, and it must be the first statement in a constructor.

  - It´s used with constructor chaining, in other words, when one constructor calls another constructor, and it helps to reduce duplicated code.

  - The only way to call a parent constructor, it by calling super(), which calls the parent constructor.

  - The Java compiler puts a default call to super(), if we don´t add it, and it´s always a call to the no argument constructor, which is
    inserted by the compiler.

  - The call to super() must be the first statement in each constructor.

  - A constructor can have a call to super() or this(), but never both.

------------------------------------------------------------------------------------------------------------------------------------------------

Constructors Bad example:


  class Rectangle{

      private int x;
      private int y;
      private int width;
      private int height;

      public rectangle(){
          this.x = 0;
          this.y = 0;
          this.width = 0;
          this.height = 0;
      }

      public Rectangle(int width, int height){
          this.x = 0;
          this.y = 0
          this.width = width;
          this.height = height;
      }

      public Rectangle(int x, int y, int width, int height){
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
      }
  }

  Here, we have three constructors.

  All three constructors initializa variables.

  There´s repeated code in each constructor.

  We´re initializing values in each constructor, with some default values.

  You should NEVER write constructors like this.

  Let´s look at the right way to do this, by using a this() call.
  ---------------------------------------------------------------------------------------------------------------------------------------------
Constructors Good Example:


  class Rectangle{

      private int x;
      private int y;
      private int width;
      private int height;

      // 1st constructor
      public rectangle(){
          this(0,0);          // calls 2nd constructor
      }

      // 2nd constructor
      public Rectangle(int width, int height){
          this(0, 0, width, height);             // calls 3rd constructor
      }

      // 3rd constructor
      public Rectangle(int x, int y, int width, int height){
          // initialize variables
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
      }
  }

In this example, we still have three constructors.

The 1st constructor calls the 2nd constructor, the 2nd constructor calls the 3rd constructor, and the 3rd constructor initializes the
instance variables.

The 3rd constructor does all the work.

No matter what constructor we call, the variables will always be initialized in the 3rd constructor.

This is known as constructor chaining, the last constructor has the responsibility to initialize the variables.
------------------------------------------------------------------------------------------------------------------------------------------------

super() call example:

  class Shape{

      private int x;
      private int y;

      public Shape(int x, int y){
          this.x = x;
          this.y = y;
      }
   }


   class Rectangle extends Shape{

      private int width;
      private int height;

      // 1st constructor
      public Rectangle(int x, int y){
          this(x, y, 0, 0);                // calls 2nd constructor
      }


      public Rectangle(int x, int y, int widht, int height){
          super(x, y);                                              // calls the constructor from parent class(Shape)
          this.width = with;
          this.height = height
      }
   }

In this example, we have a class Shape with x and y variables, and a class Rectangle that extends Shape, with variables width and height.

In the Rectangle class, the 1st constructor is calling the 2nd constructor.

The 2nd constructor calls the parent constructor, with parameters x and y.

The parent constructor will initialize the x and y variables, while the 2nd Rectangle constructor will initialize the width and height variables.

Here, we have both the super() and this() calls.






                  





    

    


    






