What is object oriented programming

    - Object oriented programming is a way to model real world objects, as software objects, which contain both data and code.

    - OOP is a common acronym for Object Oriented programming

Class-based programming

    - Class-based programming starts with classes, which become blueprints for objects.


State and Behaviour

    - Now, real world objects have two major coomponents: (state and behaviour)

    - State, in terms of a computer object, might be: The amout of RAM it has, the operating system it´s running, the hard drive size.

    - These are characteristics about the item, that can describe it.

    - Behaviour(computer): In addition to state, objects may also have a behaviour, or actions that can be performed by the object or upon the
      object. Behaviour, for a computer, might be things like: booting up, shuting down, outputing some form of sound, drawing something on the
      screen and so son.

    - So modelling real world objects as software objects, is a fundamental part of Object Oriented Programming.

    - Now, a software object stores its state in fields, which can also be called variables, or attributes.

    - And objects expose their behaviour with methods, which we-ve talked about before.

    - So, where does a class fit in?

    - Well, think of a class as a template, or blueprint for creating objects.

The class as the blueprint

    - The class describes the data(fields), and the behaviour (methods), that are relevant to the real world object we want to describe.

    - These are called class members.

    - A class member can be a field, or a method, or some other type of dependant element.

    - If a field is static, there is only one copy in memory, and this value is associated with the class, or template itself.

    - If a field is not static, it´s called an instance field, and each object may have a different value stored for this field.

    - A static method can´t be dependant on any one object´s state, so it can´t reference any instance members.

    - In other words, any method that operates on instance fields, needs to be non-static.
------------------------------------------------------------------------------------------------------------------------------------------------

Organizing classes

    -Classes can be organized into logical groupings, which are called packages.

    -You declare a package name in the class using a package statement.

    -If you don´t declare a package, the class implicitly belongs to the default package.

    - You do need to understand that classes are grouped into packages, to understand acess modifiers.


Acess modifiers for the class

    - A class is said to be a top-level class, if it is defined in the souce code file, and not enclosed in the code block of another class,
    type, or method.

    - A top level class has only two valid acess valid modifier options: public, or none.
        
        public: public means any other class in any package can acess this class.

        (empty): When the acess modifier is omitted, this class has special meaning, called package acess, meaning that the class is
                 acessible only to classes in the same package.


Acess modifiers for class members

    - An acess modifier at member level, allows granular control over class members.

    - The valid acess modifiers are shown in this table from the least restrictive, to the most restrictive

        public: public means any other class in any package can acess this class.

        protected: protected allows classes in the same package, and any subclasses in other packages, to have acess to the member

        (omitted): When the modifier is omitted(not specified), this class has special meaning, called package acess, meaning the member
                   is acessible only to classes in the same package.

        private: private means that no other class can acess this member

    - As a general rule, all your fields should be private, unlike the class, where we´ll usually use public. So why would we want to make
      all the fields on a class private? Doesn´t this mean that nobody can acess them? This practice has a name, encapsulation, and it´s A
      key fundamental rule of Object Oriented Programming.


Encapsulation


    - Encapsulation in Object Oriented Programming usually has two meanings.

    - One is the bundling(empacotamento) of behaviour and attributes on a single object.

    - The other is the practice of hiding fields, and some methods, from public acess.

    - In general, when we´re talking about encapsulation, we´re talking about information hiding, or hiding the internal workings of a 
      particular object. When we make our attributes private, we can then create methods to acess the data, with different degrees of
      acess allowed, as needed.

============================================================================================================================================
What is null?

    - null is a special keyword in Java, meaning the variable or attribute has a type, but no reference to an object.

    - This means that no instance, or object, is assigned to the variable or field.

    - field with primitive data types are never null.

    - So, why is the color, make, and model of the car null? Well, all of these fields were declared with the String data type, and we
      haven´t assigned values to them. We know from previous lectures that Strings are really objects, and not primitive data types,
      so Java assigned each a null reference.

    - the other thind i want you to notice about the output we got, was that doors was printed with the value 0(Car class) and that the world
      convertible wasn´t printed in the output. So, how is that possible? We didn´t set doors or convertible to any values in our class, but
      we didn´t get any erros when running this code. And now, we´re seeing another difference between local variables, and fields declared on
      a class.

    - And this is that a field with primitive data type, will get assigned a defaul value by Java.


Default values for fields on classes

    - Fields on clases are assigned default values, intrinsically by Java, if not assigned explicitly.

        boolean:                         defalt value assigned is false

        byte, short, int, long, char:    default value assigned is 0

        double, float:                   default value assigned is 0.0

        any other data type:             default value assigned is null
----------------------------------------------------------------------------------------------------------------------------------------------------

What are getters and setters? Why should we use them?

    - A getter is a method on a class, that retrives the value of a private field, and returns it.

    - A setter is a method on a class, that sets the value of a private field.

    - The purpose of these methods is to control, and protect acess to private fields.

    - Another important aspect, is that the getter and setter method signatures are part of car's public interface, but the attribute names
      and types aren´t. This means that we can chage things internally, like the name or type of an attribute, but as long as we use the
      same getter and setter method, these changes should  have no effect on code that uses our class. Our internal changes are hidden from
      our users.

    - A getter method usually just returns the value of a private attribute. It´s usual to name a getter method with the get prefix, followed
      by the field name, in lower camel case, but this is not required.

    - You could have getter methods for attributes that are not really declared on your class, but that are derived in some way.

    - A setter may simply just assign the argument passed to the attribute, but it often contains code to validate dara, check additional
      security requirements, ensure immutability of the field value, or any other code required to protect and validate an object´s state.

    - It´s usual to name a setter method with the set prefix, followed by the field name, in lower camel case, but again, this is matter of
      form. There may be cases where we won´t have any setter methods, for some of our private fields. Maybe this is data only needed within
      the class itself, and doesn´t need to be exposed to the outside world.

-----------------------------------------------------------------------------------------------------------------------------------------------
this keyword

     - this is a special keyword in Java.
     
     - What it really refers is to the instance that was cerated when the object was instantiated.

     - So "this" is a special reference name for the object or instance, which can be used to describe itself.

     - And we can use "this" to acess fields on the class.


Interesting details:

    Car car;
    car.setMake("Porsche");

    - We haven´t included the = new Car part. Already, IntelliJ is saying "Variable car may not have been initialized" where we are
      attempting to call the setter method, on the car variable. You can´t use an unitialized variable, which car is, because we haven´t
      assigned any object reference to it. But now, consider what happens, if we instead assign null to car
 
    Car car = null;
    car.setMake("Porsche");

    - So IntelliJ is not showing any erros when we do this, but let´s try running it.

        Exception in thread "main" java.lang.NullPointerExceptio: Cannot invoke "Car" at Main.main

    - We actually get an exception, NullPointerException, and the additional information that we can´t call a method, or invoke a method
      (instance method) on a null instance. And what that essentialy means, is we´ve defined a variable called car, but it doesn´t have a
      reference to a valid instance of a Car.
    
    - So we can´t run a method on a null, and we couldn´t set, or get attributes on a null.

    - So there´s a dinstinction here i want to point out, between an uninitialized variable, and a variable with a null reference.

    - An uninitialized variable, as we saw in the first instance, causes a compile time error. But a variable with a null reference can be
      be used in code, without compile errors, but will throw an expection at runtime.

    - So, in both of these scenarios, we haven´t created an object from the Car template, which of course is the class. So, that´s why you need
      to make sure that new is always executed. The bottom line i´m trying to say here is that, make sure when you´re creating objects, you always
      use the keyword new, and them include the name of the class, and then follow it with the parentheses.
=======================================================================================================================================================

Constructor

A constructor is used in the creation of an object, that´s an instance of a class.

It is a special type of code block that has a specific name and parameters, much like a method.

It has the same name as the class itself, and it doesn´t return any values.

You never include a return type from a constructor, not even void.

You can, and should, specify an appropriate access modifier, to control who should be able to create to create new instances of the class.



    public class Account{   //This is the class declaratiom

      public Account(){  // This is the constructor declaration
          // Constructor code is code to be executed as the object is created.
      }
    }
  

The default constructor

If a class contains no constructor declarations, then a default constructor is implictly declared.

This constructor has no parameters, and is often called the no-args (no arguments) constructor.

If a class contains any other constructor declarations, then a default constructor is NOT implicitly declared




The purpose of the constructor is, to essentially initialize the object that we´re creating, and do whatever else we need to happen,
while the object is being instantiated.



Constructor overloading is declaring multiple constructors, with different formal parameters.

The number of parameters can be different between constructors.

Or if the number of parameters is the same between two constructors, their types or order of types must differ.

================================================================================================================================================

Constructor chaining with this()

Constructor chaining is when one constructor explicitly calls another overloaded constructor.

You can call a constructor only from another constructor

You must use the special statement this() to execute another constructor, passing it arguments if required.

And this() must be the first executable statement, if it´s used from another constructor.

==============================================================================================================================================

Reference vs Object vs Instance vs Class



Let´s use the analogy building a house to understand classes.

A class is basically a blueprint for the house

Using the blueprint, we can build as many houses as we like, based on those plans.

Each house we build (in other words using the new operator) is an object.

This object can also be known as an instance, often we´ll say it´s an instance of the class. So we would have an instance of house
in this example.

Each house we build has an address(a physical location).

In other words, if we want to tell someone where we live, we give them our address (perhaps written on a piece of paper). This is known as
a reference.

We can copy that reference as many times as we like, but there is still just one house that we´re referring to.

In other words, we´re copying the paper that has the address on it, not the house itself.

We can pass references as parameters to constructors and methods.

================================================================================================================================================

Static vs Instance variables


Static variables

 - Declared by using the keyword static.

 - static variables are also known as static member variables.

 - Every instance of the class shares the same static variable.

 - So if changes are made to that variable, all other instances of that class will see the effect of that change.

 - It is considered best practice to use the Class name, and not a reference variable to acess a static variable.

    class Dog{
        
        static String genus = "Canis";

        void printData(){
          Dog d = new Dog();
          System.out.println(d.genus);     // Confusing!
          System.out.println(Dog.genus);   // Clearer!
        }
    }

    This makes it clearer that the variable is associated with the Class, and therefore shared and the value is not stored with the
    instance.

  - An instance insn´t required to exist, to acess the value of a static variable.

    class Dog{
      static String genus = "Canis";
    }

    class Main{
      public static void main(String [] args){
        System.out.println(Dog.genus);          //No instance of dog needs to exist in order to acess a static variable.
      }
    }

  - Static variables aren´t used very often, but can sometimes be very useful.

  - They can be used for:
    Storing counters.
    Generating unique ids.
    Storing a constant value that doesn´t change, like PI for example.
    Creating and controlling acess, to a shared resource.


    - example of code:

      class Dog{

        private static String name;

        public Dog(String name){
            Dog.name = name;
        }

        public void printName(){
            System.out.println("name = " + name);   // Using Dog.name would have made this code less confusing
        }
      }


      public class Main{

        public static void main(String [] args){

            Dog rex = new Dog("Rex");            // create instance (rex)
            Dog fluffy = new Dog ("Fluffy");     // create instance (fluffy)
            rex.printName();                     // prints Fluffy
            fluffy.printName();                  // prints Fluffy
        }
      }

      Both method calls print fluffy, why is that the case? Well, remember that static variables are shared between instances. So, in other
      words, once we change the static variable, all instances will see that change. So, when we called the cosntructor with the parameters
      fluffy, it modified the static variable name, because both instances are sharing that variable. So, you could say that all dogs have
      the same name, but that´s logically incorrect. So, hopefully, now you can see how static variables can be used inappropriately sometimes,
      as in this example.



      Instance variables

       - They don´t use the static keyword.

       - They´re also known as fields, or member variables.

       - Instance variables belong to a specific instance of a class.

       - Each instance has its own copy of an instance variable.

       - Every instance can have a different value.

       - Instance variables represent the state of a specific instance of a class.

       - Let´s see an example:
         
         
         class Dog{

            private String name;
            
            public Dog(String name){
               this.name = name;
            }

            public void printName(){
               System.out.println("name = " +name);
            }
         }

         public class Main{

            public static void main(String []args){

                Dog rex = new Dog("Rex");               // create instance (rex)
                Dog fluffluy = new Dog("Fluffy");       // create instance (fluffy)
                rex.printName();                        // prints Rex
                fluffly.printName();                    // prints Fluffy
            }
         }

================================================================================================================================================


Static vs Instance methods


Static Methods

  - Static methods are declared using a static modifier.

  - Static methods can´t acess instance methods and instance variables directly.

  - They´re used for operations that don´t require any data from an instance of the class (from 'this')

  - If you remember, the this keyword is the current instance of a class.

  - So, inside a static method, we can´t use the this keyword

  - Whenever you see a method that doesn´t use instance variables, that method should probably be declared as a static method.

  - For example, the main is a static method, and it´s called by the Java Virtual Machine when it starts the java application.

  - Static method example:


      class Calculator{
          
          public static void printSum(int a, int b){
              System.out.println("sum = "+ (a+ b));
          }
      }


      public class Main{
          
          public static void main(String [] args){
              Calculator.printSum(5, 10);
              printHello();                    // shorter form of Main.printHello();
          }

          public static void printHello(){
              System.out.println("Hello");
          }
      }

    - Static methods are called as ClassName.methodName(); or methodName(); only if in the same class


Instance methods

  - Instancce methods belong to an instance, of a class.

  - To use an instance method, we have to instantiate the class first, usually by using the new keyword.

  - Instance methods can acess instance variables directly.

  - Instance methods can also acess static methods and static variables directly.

  - What i mean by directly is that we don´t usually have to use the keyword this, with the dot notation to use them. And we don´t have
    to use the Class name with the dot notation to acess static variables, though that can help with clarity.

  - Instance Method example:

      class Dog{

          public void bark(){
              System.out.println("woof");
          }

          public class Main{

              Dog rex = new Dog();               // create instance
              rex.bark();                        // call instance method
          }
      }

    - So, the hard part here could be deciding when to create an instance, or when to create a static method. So, let´s see some basic rules
      that could help you decide.


          1) Shoud a method be static?

          2) Does it use any fields (instance variables) or instance methods?

          3) Yes: It should probably be an instance method.

          4) No: It should probably be an static method.

=================================================================================================================================================

The POJO

  - A plain old Java object (whose acronym is POJO) is a class that generally only has instance fields.

  - It´s used to house data, and pass data, between functional classes.]

  - It usually has few, if any methods other than getters and setters.

  - Many database frameworkds use POJO´s to read data from, or to write data to databases, files or streams.

  - You´ll remember, i´ve said several times that a class can be thought of as a super data type. A POJO is really just that. It let´s you
    extend and combine, your definition of data types.

   
    Examples of POJOS

      - A POJO also might be called a bean, or a JavaBean.

      - A JavaBean is just a POJO, with some extra rules to applied to it.

      - These rules are in place, so that Java frameworks have a standard way to manipulate, and manage these objects.

      - A POJO is sometimes called an entity, because it mirrors database entities.

      - Another acronym is DTO, for Data Transfer Object.

      - It´s a description of an object, that can be modeled as just data.

      

      Support for POJO creation

        - There are many tools, that will turn a data model into generated POJO´s or JavaBeans.

        - You´ve seen an example of similar code generation in IntelliJ, which allowed us to generate getters, setters, and constructors
          in a uniform way.

          - Let´s look at an example of a POJO in code(RecordProject folder). Let´s say we want to read data out of a database, that has a
            table of Student records.

          - The Entity - The Student table

                  Student

                  Id
                  Name
                  DateOfBirth
                  ClassList


Annotation (@)

  - Annotations are a type of metadata.

  - Metadata is a way of formally describing additional information about our code.

  - Annotations are more structured, and have more meaning than comments.

  - This is because they can be used by the compiler, or other types of pre-processing functions, to get information about the code.

  - Metadata doesn´t affect how your code runs, so this code will still run. with, or without the annotation.

  - Override is one of the most common annotations in Java that you´ll use.

  - It tells that compiler that this is a special type of method in Java, an overriden method.



Overriden Method

  - An overriden method is not the same as an overloaded method.

  - An overriden method is a special method in Java, that other classes can implement, if they use a specified method signature.

===============================================================================================================================================

The POJO vs The Record

  - In the last video, we talked about the Plain Old Java Object, and we showed you how it comes with a lot of what we call boilerplate code.

  - It´s code that´s repetitive, and follows certain rules.

  - In our case, we had a constructor with parameters for every field on our class, as well as getters and setters for each field. We also
    set up a toString method on this class, so we could print out all the fields on our class in a nicely formatted way.

  - This is code that´s repeated over and over, for every POJO, or for every JavaBean, if you are using JavaBeans to leverage Java frameworks
    that use them.

  - Once created, this code is rarely looked at, or modified.

  - In fact, there are tools that´ll just regenerate all of this code, if your underlying data, or domain model changes.

  - Even better though, Java introduced a new type, the record, which became part of the official language, in JFK 16.
  

The Record type

  - The record was introduced in JDK 14, and became officialy part of Java in JDK 16.

  - It´s purpose is to replace the boilerplate code of the POJO, but to be more restrictive.

  - Java calls them "plain data carriers".

  - The word carrier is an important term, because it means the record has more rules built-in then a POJO would.

  - The record is a special class that contains data, that´s not meant to be altered.

  - In other words, it seeks to achieve immutability, for the data in its members.

  - It contains only the most fundamental methods, such as constructors and accessors.

  - Best of all, you the developer, don´t have to write or generate any of this code.

  - Why is the record built to be immutable?

      The are more use cases for immutable data transfer objects, and keeping them well encapsulated.

      You want to protect the data from unintended mutations.


Pojo vs Record

  - If you want to modify data on your class, you won´t be using the record.

  - you can use the code generation options for the POJO, as we showed in the earlier video.

  - But if you´re reading a lot of records from a database or file source, and simply passing this data around, then the record is a big
    improvement.

We´ve only touched some of the features of the record to give you an introduction. When we do talk more about the final keyword, and
immutability of data, especially as it may be affected by concurrent threads, we´ll be revisiting this type. We´ll also be showing it to
you in action, when we get to the database and I/O sections of this course.

=================================================================================================================================================









                  




    

    


    






